// script data and interpreter
// generated by msc3nes by the mojon twins

const unsigned char script_pool [] = {
/*            0     1     2     3     4     5     6     7     8     9     A     B     C     D     E     F */
/* 0000 */ 0x20, 0x00, 0x30, 0x00, 0x38, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 
/* 0001 */ 0x50, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
/* 0002 */ 0x0e, 0x10, 0x05, 0x06, 0xff, 0x20, 0x08, 0x06, 0x03, 0x51, 0xe9, 0x01, 0xff, 0x7f, 0xff, 0xff, 
/* 0003 */ 0x06, 0x21, 0xe1, 0xff, 0xff, 0xf1, 0xff, 0xff, 0x06, 0xf0, 0xff, 0x86, 0x98, 0x05, 0xff, 0xff, 
/* 0004 */ 0x06, 0xf0, 0xff, 0x86, 0x94, 0x01, 0xff, 0xff, 0x06, 0xf0, 0xff, 0x86, 0x5e, 0x02, 0xff, 0xff, 
/* 0005 */ 0x0e, 0xf0, 0xff, 0x86, 0x31, 0x03, 0x86, 0x4d, 0x04, 0x51, 0xb9, 0x31, 0xcf, 0x4f, 0xff, 0xff, 
/* 0006 */ 0x15, 0xf0, 0xff, 0x01, 0x00, 0x00, 0x01, 0x01, 0x04, 0x01, 0x02, 0x05, 0x01, 0x03, 0x06, 0x01, 
/* 0007 */ 0x04, 0x07, 0x01, 0x05, 0x00, 0xff, 0xff
};

#ifdef CLEAR_FLAGS
void msc_clear_flags (void) {
    memfill (flags, 0, MAX_FLAGS);
}
#endif

unsigned char read_byte (void) {
	return *script ++;
}

unsigned char read_vbyte (void) {
	sc_c = *script ++;
	if (sc_c & 128) return flags [sc_c & 127];
	return sc_c;
}

void readxy (void) {
	sc_x = read_vbyte ();
	sc_y = read_vbyte ();
}

void run_script (unsigned char whichs) {
	// read address offset from index
	gp_gen = (unsigned char *) script_pool + whichs + whichs;
	rda = *gp_gen ++; rdb = *gp_gen;
	script_result = 0;
	sc_continuar = 0;
	if (!(rda | rdb)) return;
	script = (unsigned char *) script_pool + rda + (rdb << 8);

	// todo : update selected item flag

	while ((sc_c = read_byte ()) != 0xff) {
		next_script = script + sc_c;
		sc_terminado = sc_continuar = 0;
		while (!sc_terminado) {
			switch (read_byte ()) {
				case 0x10:
					// IF FLAG sc_x = sc_n
					// Opcode: 10 sc_x sc_n
					readxy ();
					sc_terminado = (flags [sc_x] != sc_y);
					break;
				case 0x21:
					// IF PLAYER_IN_X x1, x2
					// Opcode: 21 x1 x2
					sc_x = read_byte ();
					sc_y = read_byte ();
					sc_terminado = (!(prx >= sc_x && prx <= sc_y));
					break;
				case 0xF0:
					 // IF TRUE
					 // Opcode: F0
					 break;
				case 0xff:
					// then
					// opcode: ff
					sc_terminado = sc_continuar = 1;
					break;
			}
		}

		if (sc_continuar) {
            fire_script_success |= sc_continuar;
			sc_terminado = 0;
			while (!sc_terminado) {
				switch (read_byte ()) {
					case 0x01:
						// SET FLAG sc_x = sc_n
						// Opcode: 01 sc_x sc_n
						readxy ();
						flags [sc_x] = sc_y;
						break;
					case 0x20:
						// SET TILE (sc_x, sc_y) = sc_n
						// Opcode: 20 sc_x sc_y sc_n
						readxy ();
						_x = sc_x; _y = sc_y; _t = read_vbyte (); map_set ();
						break;
					case 0x51:
						// SET_FIRE_ZONE x1, y1, x2, y2
						// Opcode: 51 x1 y1 x2 y2
						fzx1 = read_byte ();
						fzy1 = read_byte ();
						fzx2 = read_byte ();
						fzy2 = read_byte ();
						f_zone_ac = 1;
						break;
					case 0x86:
						// ADD_CONTAINER f, x, y
						sc_x = read_byte (); sc_y = read_vbyte ();
						containers_add ();
						break;
					case 0xF1:
						// WIN
						script_result = 1;
						return;
					case 0xff:
						sc_terminado = 1;
						break;
				}
			}
		}
		script = next_script;
	}
}
